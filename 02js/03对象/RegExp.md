字符串是编程时涉及到最多的一种数据结构，对字符串操作的需求几乎无处不在。
正则表达式是一种用来匹配字符串的强有力武器。它的设计思想是用一种描述性语言来给字符串定义一个规则，凡是符合规则的字符串我们就认为它“匹配”了。否则该字符串就是不合法的。
## 字符描述字符
- 直接给出字符就是精确匹配
- \d匹配数字,\w匹配字符或数字
- . 匹配任意字符

所以 '00\d' 可以匹配 '007'，但是无法匹配 '00A'。'\d\d\d'可以匹配'010'。'\w\w'可以匹配'js'。'js.'可以匹配'jsp'等。
## 更长字符
\* 表示任意个字符。 + 表示至少一个字符。？表示0或1个字符。{n}表示n个字符。{n,m}表示 n到m个字符
例子：\d{3}\s+\d{3,8}
1. \d{3}表示匹配3个数字。如'010'
2. \s可以匹配一个空格，也包括Tab等空白字符。所以\s+表示至少有一个空格。匹配如：' ','\t\t'等。
3. \d{3,8}表示3-8个数字。例如'1234567'

## 更精确
要做更精确的匹配，使用**[]**表示范围
- [0-9a-zA-Z\_]可以匹配一个数字、字母或下划线
- [0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或下划线组成的字符串
- [a-zA-Z\_\$][0-9a-zA-Z\_\$]*可以匹配由字母或下划线、$开头，后接任意个由数字、字母或下划线、$组成的字符串。
- A|B 可以表示匹配A或B。所以(J|j)ava(S|s)cript可以匹配'JavaScript'、'javaScript'...
- ^ 表示行的开头，^\d表示必须以数字开头
- $ 表示行的结束，\d$表示必须以数字结束

js也可以匹配到 'jsp',但是 ^js$ 就变成了整行匹配，就只能匹配js了。

## RegExp
js中使用正则表达式。
### 两种方式创建一个正则表达式：
1. **/正则表达式/**写出来。
2. **new RegExp('正则表达式')**创建一个RegExp对象
```
var re2 = new RegExp('AB\\-001'); 
```
注意第二种写法因为字符串转义问题，所以需要写为 \\ 。
### 判断正则表达式是否匹配
```
var re = /^\d{3}\-/;
re.test('010-12345'); //true
re.test('010 123"); //false
```
### 使用
#### 切分字符串
'a,b,c,  d'.split(/[\s\,]+/);
#### 分组
除了匹配还可以**提取子串**。用**()**表示的就是要提取的分组：
```
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345');
re.exec('010 12345');
```
如果正则表达式中定义了组，就可以在 RegExp 对象上调用 **exec**函数提取出子串来。
exec() 方法匹配成功后，会返回一个 Array。第一个元素是匹配的整个字符串，后面的是匹配成功的子串。
exec() 匹配失败时返回 null。

### 贪婪匹配
特别的是，正则匹配都是默认贪婪匹配，即尽可能多地匹配更多字符。如：
```
var re = /^(\d+)(0*)$/;
re.exec('102300'); // 102300,102300,''
```
由于 \d+ 采用贪婪匹配，直接把后面的 0 匹配了，所以后面的 0* 只能匹配到空串了。
必须让\d+采用非贪婪匹配，即尽可能少匹配，才能把后面的0匹配出来。加个 ？ 就可以让\d+采用非贪婪匹配
```
var re = /^(\d+?)(0*)$/;
re.exec('102300');
```

### 全局搜索
js 的正则表达式有几个特殊标志，最常用的是 **g**，表示全局匹配：
```
var r1 = /test/g;
等价于
var r2 = new RegExp('test','g');
```
全局匹配可以多次执行 exec() 方法来搜索一个匹配的字符串。当我们指定 g 标志后，每次运行 exec，正则表达式本身会更新 lastIndex 属性，表示上次匹配到的最后的索引。
```
var s = 'javascript,VBScript,JSCript' ;
var re = /[a-zA-Z]+Script/g;

re.exec(s); // [javascript]
re.lastIndex; //10

re.exec(s); // [VBScript]
re.lastIndex; //20

匹配完毕后则最后返回null。
```